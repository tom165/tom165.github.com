---
author: tom165
comments: true
date: 2011-03-21 12:56:49+00:00
layout: post
slug: steve-adams%e7%9a%84%e3%80%8aoracle8i-internal-services-for-waits-latches-locks%e3%80%8b-%e7%ac%ac%e4%b8%89%e7%ab%a0-%e9%97%a93-1-%e9%97%a9%e5%92%8c%e9%94%81
title: Steve Adams的《oracle8i.internal.services.for.waits.latches.locks》-第三章 闩3.1 闩和锁
wordpress_id: 11
categories:
- Oracle翻译
---

第三章   闩

ORACLE系统全局区(SGA)里有无数数据结构，许多不同的数据库进程需要对它们进行并发读写。任何数据结构在某一时刻只能被一个进程修改，并且在被查看时是不能被修改的。oracle通过锁或闩来保护SGA中的数据结构来确保这种情况不会发生。

3.1 闩和锁

闩理论上比锁更受限制，因为闩只提供排他性的读取，不允许多个进程同时查看被保护的数据结构（注1），而锁有更好的并发性，允许数据结构在共享模式下简单的查看。
注1：这是简化的说法，redo复制闩能在基于硬件的条件下被共享。<!-- more -->

闩和锁的另一个有意思的区别是在请求队列上。如果需要锁的请求是按队列排序服务的，但闩不支持请求队列。加入一个闩的请求由于闩太忙而失败，进程将继续重试直到成功，所以闩不必排序服务。

由于闩在某个时刻只能被一个进程持有，且没有队列的概念，闩本身的数据结构是非常简单的--本质上只是一个内存中的存储单元，用于表示闩的状态。由于闩的 数据结构如此简单，闩的获得和释放都是非常轻松的。相反，由于锁支持队列和并发，锁的数据结构复杂得多，锁在获得、转换、释放上要做更多的工作。

对于oracle来说，同一时刻保证只有一个进程能修改自己的闩和锁的数据结构是理所当然的。对闩而言这很简单，因为每个闩只是内存中的一个存储单 元，oracle能用基本的硬件指令（如TEST和SET，LOAD和CLEAR，COMPARE和SWAP指令）对闩进行操作。由于不需要其他锁保护机 制，这些简单的指令能保证操作是原子级的。这种简单性使闩的效率非常高。

另一方面，oracle的锁结构有好几部分，不能在原子操作级别上修改。所以，oracle实际上用闩来保护锁的操作。不同类型的闩用来保护不用类型的 锁。例如，缓存锁简介的被缓存链闩保护，行缓存队列锁被行缓存对象闩保护。由于闩比锁更有效，在短时和间歇读取数据时，oracle经常用闩来保护数据， 而不是锁和联合闩。
