---
author: tom165
comments: true
date: 2011-03-21 12:51:41+00:00
layout: post
slug: steve-adams%e7%9a%84%e3%80%8aoracle8i-internal-services-for-waits-latches-locks%e3%80%8b-%e7%ac%ac%e4%ba%8c%e7%ab%a0-2-1%e4%bf%a1%e5%8f%b7%e9%87%8f
title: Steve Adams的《oracle8i.internal.services.for.waits.latches.locks》-第二章 2.1信号量
wordpress_id: 8
categories:
- Oracle翻译
---

第二章： 等待事件
在一个oracle实例中许多进程或线程（单进程中）一起运行。为了一起运行，他们之间要互相通讯，一个主要的通讯手段是信号量。一个信号量就是一种信号。有点像铁路信号，告诉列车是停止还是等待，何时开。oracle服务器进程经常需要停止和等待：
有时因为资源不可等到
有时因为没有任务
有时因为需要等待其他服务器进程完成预先任务
信号量能让oracle服务器进程停止和等待，并通知他们何时重新开始处理<!-- more -->

2.1信号量
每一个oracle服务器进程都有一个信号量。进程在需要等待资源、需要去做某一任务、需要某一任务完成时都等待信号量。当资源释放、任务可以去做、预先任务已完成时，停止等待的信号量就发布了。

例如，在一个用户进程把redo信息写进redo日志缓存时，写日志写进程（LGWR）可能等待工作的信号量。当用户提交时，LGWR必须写入redo, 并且在用户等待时提交日志文件的标记。为了完成这些工作，用户进程发布LGWR的信号量，表明LGWR可以停止等待，有工作需要做了，然后用户进程等待它 自身的信号量。当日志文件的读写工作完成后，LGWR发布用户进程的信号量表明提交操作完成，它能进行下一事务了。LGWR因为无事可做又等待它的信号量 了。

另一个例子是，进程A要更新一行记录，但发现进程B对同一行记录的更新还没提交。进程A必须等待进程B提交。为了完成更新，进程A将等待信号量，当进程B提交时，它将发布进程A的信号量，表明可以进行更新操作了。

2.1.1 信号量特性
信号量是一个操作系统的特性。当一个oracle进程等待信号量时，操作系统不会调度它去运行。在操作系统看来，它被阻塞了，不可运行。当信号量发布，进 程的操作系统状态从阻塞变为可运行，将被尽快的调度运行。一些操作系统支持多种信号量。SYSTEM V的信号量是最常见的。SYSTEM V的信号量的数据结构由一个核心内存中的固定数组组成，它的大小由SEMMNS内核参数控制。进程必须用semop()系统调用发布或等待信号量。由于它 们是在操作系统的核心实现的，SYSTEMV的信号量在高层系统调用时不得不进行上下文切换，并由于读取内核数据结构的串行化需要而扩展性较差。

为了更好的性能和扩展性，有的操作系统也提供其他方法用于替换信号量。在一个伪设备驱动中实现了发布等待驱动事件。这些信号量的数据结构驻留在用户内存， 而不是核心内存；通过伪设备驱动，能在用户上下文环境中操作。减少了系统调用的上下文切换，提高了扩展性。但它是和特定的操作系统相关的。

POSIX实时扩展小型委员会曾经确定了一个用户内存中的信号量特性的编辑标准需求。POSIX.1b标准（早期的POSIX.4）为这个信号量特性定义了接口和实现需求，不考虑移植性的话，它是简洁高效的。

oracle使用的信号量特性是与操作系统和版本相关的。如果你的oracle安装指南中有设置SEMMNS内核参数的指令，意味著默认使用的是 System V的信号量。不幸的是这是大多数操作系统所采用的。顺便提一下，不考虑工程中的oracle进程数或其他系统和应用软件，普遍推荐设置SEMMNS为 200是被误导的。你必须让一个oracle服务器进程有一个信号量，对于其他附加需求，在表2.1中有更多说明：

你也应意识到在一些平台上，oracle实例需要它的信号量被分配再一个单一的信号量集合里。所以SEMMNI参数对每个实例仅仅允许一个信号量标识 符，SEMMSL参数（如果定义过的话）对任何实例来说必须不小于PROCESSES参数的最大值。这对vector posts是必须的。主要关键进程LGWR和DBWIN用vector posts来在单个信号量操作中提交多个等待进程。vector posts的使用依赖于_USE_VECTOR_POSTS参数的设置。

------------------------------------------------------------------------------------------------------------------------------------------------
隐藏参数
像_USE_VECTOR_POSTS一样，以底划线开始的参数是隐藏参数。因为是隐藏的，在V$PARAMETER中找不到他们，但可以用SHOW PATAMETERS命令查看。因为是未公开的，在oracle文档中也找不到它们的说明。然而，你可以用APT脚本 hidden_parameters.sql得到它们的解释，用脚本all_parameters.sql检查它们的值。有些隐藏参数是操作系统相关的。 有些只在异常回复情况下需要。有些用于打开会关闭新的功能。很多与不重要的性能问题相关。如所有的未公开特性一样，隐藏参数在将来的版本中可能消失或改 变，因此，你应该把它们作为一种终极手段，要用在oracle的技术支持检查后，并为你的继任完整的写下问题文档。
-------------------------------------------------------------------------------------------------------------------------------------------------

此外，如果你的操作系统定义了SEMMNU内核参数，它应当比操作系统层面的并发信号量工程数大。对于有许多信号量客户进程的系统，缺省值是不够的。如何 这样的话，信号量操作在峰值活跃期间将断断续续的失败并返回ORA-7264或ORA-7265错误。为了避免这种情况，SEMMNU参数必须至少与 CPU数和峰值时的CPU运行队列之和相等。

---------------------------------------------------------------------------------------------------------------------------------------------------
表2.1  System V信号量参数

参数                     解释

SEMMNS :           系统中的信号量数。除满足操作系统和其他软件的需求外，你应当要求每个oracle服务进程至少有一个信号量，更确切的说，是系统中所有实例的 PROCESSES参数的值的和。如果信号量客户端不是一直严格按关闭、启动的顺序操作的话，推荐至少加上 等于单个需求的额外补助。另外，由内核参数控制的单个用户同时拥有的最大进程数（一般称作MAXUP），应不小于SEMMNS的值，额外的，oracle 用户的其他管理进程不需要信号量。然而，这个值不应该大到有让其他用户制造太多进程以致内核进程表被完全填满的风险。因此，由内核参数控制的所有用户的同 时最大进程数（一般称作NPROC）应该至少是SEMMNS参数值的三倍。

SEMMSL:     单个信号量集合的大小限制值。有些操作系统未定义这个参数。一旦它定义了，oracle就要求一个实例的所有信号量分配在也个单独信号量集合中。这个参数必须不小于任意实例要求的PROCESSES参数的最到值。

SEMMNI:    系统中的信号量集合的标识符数。除满足操作系统和其他软件的需求外，你应当允许每个实例有一个标识符，如果SEMMSL参数设置了多个信号量集合，任何实例可以要求多个标识符。

SEMMNU:   系统中的信号量undo结构数。在信号量操作的异常进程关闭事件中，undo结构用于恢复内核信号量数据结构。SEMMNU值应当大于峰值时的运行和可运行的进程数。
-------------------------------------------------------------------------------------------------------------------------------------------------------------

如果你的操作系统中oracle缺省使用system V 信号量，同时也支持使用post-wait driver,应该选择使用post-wait driver。这通常要把USE_POST_WAIT_DRIVER参数设为TRUE，有时还必须设置POST_WAIT_DEVICE参数。因为与操作 系统和版本相关，请查阅oracle安装指南。

如果你的安装指南没有涉及内核信号量参数设置和post-wait driver,那你的操作系统的信号量功能的选择和配置是自动的。

注：信号量参数是操作系统内核参数，不能在oracle初始化参数文件INIT.ORA中设置。

2.1.2  调度潜伏期
当一个进程提交后，它的操作系统状态从阻塞变为可运行。然而，这并不意味着它将立即被调度在CPU上执行。它必须至少等待操作系统的进行调度器的下一次执 行，如果有更高优先级的进程在等待执行，那还要等待更久。一个进程从提交到开始执行的间隔时间就是调度潜伏期。调度潜伏期对oracle的响应时间的影 响，在图2.1中有解释，性能调优的一个重要部分是缩短调度潜伏期。

许多操作系统的调度算法会调整进程的执行优先级，使之与他们最近使用CPU的时间大小成比例。不幸的是，在很繁忙的oracle环境中，这会降低如 LGWR，DBWn，LCKn，LMDn等关键后台进程的执行优先级。会使这些进程的调度潜伏期增加，在极端情况下，会形成这些被影响的后台进程服务的全 部实例的瓶颈。

有的操作系统支持多种调度算法。有可能的话，你应该选择不会象上面讲的一样降低进程执行优先级的调度算法。为了弥补这个缺点，你的操作系统可能提供了一种 优先级固定的特性。如果进程的执行优先级被固定了，就不会被降低了。在一些情况下 ，所有用户都可使用优先级固定，oracle会自动使用它。在其他情况下，只有系统管理员和特别授权用户可使用优先级固定，oracle用户必须被授权才 可使用优先级固定，或者用系统管理员用一个固定优先级的命令行脚本启动oracle实例，这样所有的oracle进程就用固定优先级执行了。

当优先级固定不可用时，从优先级的降低原理考虑，为获得相同的效果，你可以人工调高关键后台进程的执行优先级和，或用实时进程优先级来执行。由于 oracle经常推荐所有oracle进程用相同的优先级执行，你可能不愿这么做。这个推荐方法是为了防止由于低优先级的进程占用了关键资源但由于没有 CPU使用时间而无法释放，而其他高优先级进程试图重复获得该资源。但调高关键后台进程的执行优先级极少发生这种情况。如果这些进程要求的资源得不到，它 们不久将变为休眠状态，除此以外，只使用与其他实例的工作数量所成比例的CPU时间。所以它们对其他oracle进程没有CPU空闲风险。

2.1.3 超时
oracle服务进程从不愿无限期的等待，免得永远被提交和等待。幸运的是，信号量等待可以被中断。所以在oracle进程开始等待信号量前，他通过设置 一个警告定时，也叫超时时间来中断他的休眠期。如果进程提交了，警告定时会关掉并继续执行；如果定时被超时，等待就通过一个SIGALRM信号被中断。进 程又有机会重新评估状况，并决定是否继续等待。

例如，一个进程在等待队列锁，当定时被超时，会检测是否死锁。如果有死锁，会回滚并引起一个异常，如果没有死锁，进程会设置一个新的定时并重新开始等待信号量。

有时会发生进程定时太短，以致于关闭定时的警告都来不及发布。对这种情况，oracle进程会在跟踪文件中写入一条消息： Ignoring SIGALRM，如果你发现以上信息的跟踪文件，这没有任何告警。它仅仅告诉你等待进程提交速度并不像你想像的一样快。你应该从等待时间统计中找到一些问 题。
